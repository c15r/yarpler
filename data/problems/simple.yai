model {
      class Tag {
      }

      class Diensttyp {
        var integer anzahl;
      }

      class Mitarbeiter {
        const collection Diensttyp moeglich;
      }

      class Mitarbeitertag {
        var Diensttyp dienst;
        const Mitarbeiter mitarbeiter;
        const Tag tag;
      }
}

initial {

  # Definition von Diensttypen
  d1 = new Diensttyp(anzahl=3);
  d2 = new Diensttyp(anzahl=3);
  d3 = new Diensttyp(anzahl=1);
  f = new Diensttyp();

  # Definition von Tagen
  t1 = new Tag();
  t2 = new Tag();
  t3 = new Tag();
  t4 = new Tag();
  t5 = new Tag();
  t6 = new Tag();
  t7 = new Tag();

  # Definition von Mitarbeitern
  m1 = new Mitarbeiter();
  m2 = new Mitarbeiter();
  m3 = new Mitarbeiter();

  # Definition von Mitarbeitertagen
  m1t1 = new Mitarbeitertag();
  m1t2 = new Mitarbeitertag();
  m1t3 = new Mitarbeitertag();
  m1t4 = new Mitarbeitertag();
  m1t5 = new Mitarbeitertag();
  m1t6 = new Mitarbeitertag();
  m1t7 = new Mitarbeitertag();
  m2t1 = new Mitarbeitertag();
  m2t2 = new Mitarbeitertag();
  m2t3 = new Mitarbeitertag();
  m2t4 = new Mitarbeitertag();
  m2t5 = new Mitarbeitertag();
  m2t6 = new Mitarbeitertag();
  m2t7 = new Mitarbeitertag();
  m3t1 = new Mitarbeitertag();
  m3t2 = new Mitarbeitertag();
  m3t3 = new Mitarbeitertag();
  m3t4 = new Mitarbeitertag();
  m3t5 = new Mitarbeitertag();
  m3t6 = new Mitarbeitertag();
  m3t7 = new Mitarbeitertag();

  # Definition von Relationen

  # Mögliche Dienste pro Mitarbeiter
  relation(m1.moeglich, {d1,d2,f});
  relation(m2.moeglich, {d1,d2,d3,f});
  relation(m3.moeglich, {d2,d3,f});

  # Mitarbeitertag zu Mitarbeiter
  relation(m1t1.mitarbeiter, m1);
  relation(m1t2.mitarbeiter, m1);
  relation(m1t3.mitarbeiter, m1);
  relation(m1t4.mitarbeiter, m1);
  relation(m1t5.mitarbeiter, m1);
  relation(m1t6.mitarbeiter, m1);
  relation(m1t7.mitarbeiter, m1);
  relation(m2t1.mitarbeiter, m2);
  relation(m2t2.mitarbeiter, m2);
  relation(m2t3.mitarbeiter, m2);
  relation(m2t4.mitarbeiter, m2);
  relation(m2t5.mitarbeiter, m2);
  relation(m2t6.mitarbeiter, m2);
  relation(m2t7.mitarbeiter, m2);
  relation(m3t1.mitarbeiter, m3);
  relation(m3t2.mitarbeiter, m3);
  relation(m3t3.mitarbeiter, m3);
  relation(m3t4.mitarbeiter, m3);
  relation(m3t5.mitarbeiter, m3);
  relation(m3t6.mitarbeiter, m3);
  relation(m3t7.mitarbeiter, m3);

  # Mitarbeitertag zu Tag
  relation(m1t1.tag, t1);
  relation(m1t2.tag, t2);
  relation(m1t3.tag, t3);
  relation(m1t4.tag, t4);
  relation(m1t5.tag, t5);
  relation(m1t6.tag, t6);
  relation(m1t7.tag, t7);
  relation(m2t1.tag, t1);
  relation(m2t2.tag, t2);
  relation(m2t3.tag, t3);
  relation(m2t4.tag, t4);
  relation(m2t5.tag, t5);
  relation(m2t6.tag, t6);
  relation(m2t7.tag, t7);
  relation(m3t1.tag, t1);
  relation(m3t2.tag, t2);
  relation(m3t3.tag, t3);
  relation(m3t4.tag, t4);
  relation(m3t5.tag, t5);
  relation(m3t6.tag, t6);
  relation(m3t7.tag, t7);

}

solve {

    # Mitarbeiter kriegen nur mögliche Dienste
    constraint {
        forAll(mt in Mitarbeitertag) {
            mt.dienst in mt.mitarbeiter.moeglich
        }
    }


    # Dienstschlüssel einhalten
    constraint {
        forAll(d in Diensttyp) {
            count(d in Mitarbeitertag.dienst) == d.anzahl
        }
    }

    satisfy;
}