class MinizincTranslator < Yarpler::Extensions::Translator

  T_HEADER = "%% File generated by YARPLER"
  T_INCLUDES = "include \"globals.mzn\";"
  T_FOOTER = "solve satisfy;" # @TODO: Wird momentan als Hack missbraucht um den kompletten Durchstich zu ermÃ¶glichen ;)

  SPACE = ' '
  NEWLINE = "\n"
  LCBRACKET = '{'
  RCBRACKET = '}'
  DOUBLE_NEWLINE = NEWLINE * 2
  TAB = "\t"

  def get_array_index
    @array_index = @array_index.next
    @array_index
  end

  def before_translate(problem)
    problem
  end

  def after_translate(problem)
    minizinc_runner = MinizincRunner.new
    minizinc_runner.run(@output)

    OutputParser.new(minizinc_runner.output, problem)
    problem
  end

  def translate(problem)
    # Initialize
    @array_index = 0;

    # Setup HEADER and INCLUDES
    code = T_HEADER + DOUBLE_NEWLINE
    code << T_INCLUDES + DOUBLE_NEWLINE

    # Generate variables
    attribute_translator = MinizincAttributeTranslator.new
    code << attribute_translator.translate(problem.objects) + DOUBLE_NEWLINE

    # Generate constraints
    constraint_translator = MinizincConstraintTranslator.new
    code << constraint_translator.translate(problem) + DOUBLE_NEWLINE

    # Output
    code << 'output [ "" ' + attribute_translator.attribute_output + '];' + DOUBLE_NEWLINE

    # Footer
    code << T_FOOTER
    @output = code
  end

  class MinizincAttributeTranslator

    T_CONSTANT = "%s: %s = %s;\n" # int: id_dienst_frei = 0;
    T_OUTPUT = ", \"%s=\" , show(%s) , \" \"   "
    T_SET = "set of int: %s = {%s};\n"
    T_VARIABLE = "var %s: %s;\n" # var 0..2: m0t0;

    FIXNUM_MAX = (2**(0.size * 8 -2) -1)
    FIXNUM_MIN = -(2**(0.size * 8 -2))

    attr_reader :attribute_output

    def initialize
      @attribute_output = ''
    end

    def translate(objects)
      result = ''
      objects.each do |key, var|
        var.get_list_of_attributes
        result << convert_attributes(key, var)
      end
      result
    end

    def convert_attributes(name, resource, reference = false)
      code = ''
      resource.get_list_of_attributes.each do |a|
        case resource.get_variabletype(a)
          when 'CONSTANT'
            if reference
              next
            end
            code<< T_CONSTANT % [resource.get_datatype(a), name +'_' + a, resource.load(a)]
          when 'VARIABLE'
            code<< T_VARIABLE % [resource.load(a), name + "_" + a]
            @attribute_output << T_OUTPUT % [name + "_" + a,name + "_" + a]
          when 'HASONE'
            r = resource.get_value(a)
            if r.kind_of?(Array)
              ## Set
              if constant_range?(r)
                code << T_VARIABLE % [array_to_constant_range(r), name.to_s+"_"+ a]
              else
                set_name = "SET_"+name.to_s+"_"+ a
                code << T_SET % [set_name, array_to_set_range(r)]
                code << T_VARIABLE % [set_name, name.to_s+"_"+ a]
              end
              @attribute_output << T_OUTPUT % [name.to_s+"_"+ a,name.to_s+"_"+ a]
            else
              ## Einzelner Eintrag
              code << convert_attributes(name.to_s+"_"+r.get_instance_name.to_s, r, true )
            end
        end
      end
      code
    end

    ## Checks if the range is constant (0,1,2) or not (0,1,3)
    def constant_range?(array)
      values = Array.new
      answer = true
      array.each do |o|
        values.push(o.id)
      end
      values.sort

      last_value = nil
      values.each do |v|

        if last_value.nil?
          last_value=v
          next
        end

        if last_value+1==v
          last_value=v
        else
          answer=false
          break
        end
      end
      answer
    end

    def array_to_set_range(array)
      range = ""
      is_first = true
      array.each do |o|
        if not is_first
          range << ", "
        end
        range << o.id.to_s
        is_first = false
      end
      range
    end

    def array_to_constant_range(array)
      min = FIXNUM_MAX
      max = FIXNUM_MIN
      array.each do |o|
        if min > o.id
          min = o.id
        end

        if max < o.id
          max = o.id
        end
      end
      min.to_s + '..' + max.to_s
    end
  end

  class MinizincConstraintTranslator
    def initialize

    end

    def translate(problem)
      code = ''
      problem.constraints.each do |constraint|
        code <<  'constraint' + NEWLINE
        constraint.expressions.each do |expression|
          code << TAB + MinizincExpressionTranslator.new.translate(expression, problem) + NEWLINE
        end
        code << ';' + DOUBLE_NEWLINE
      end
      code
    end
  end

  class MinizincExpressionTranslator
    def initialize

    end

    def translate(expression, problem)
      code = '('
      case expression.operator.to_s
        when 'COUNT_IN'
          code << translate_expression_count(expression, problem)
        else
          code << translate_expression_default(expression, problem)
      end
      code << ')'
    end

    def translate_expression_count(expression, problem)

      # @TODO mach automatisch und besser
      index = 0
      first = true
      variable_to_check = resolve_variable_from_field(expression.left)
      objects = problem.get_objects_of_class(expression.right.variable)
      attribute = expression.right.attribute

      code = "let" + SPACE + LCBRACKET + "array[1.." + objects.size.to_s + "] of var int: array" +index.to_s + " = ["

      objects.each do |obj|
        if first
          first = false
        else
          code << ","
        end
        code << "bool2int("+variable_to_check + "==" + resolve_variable_from_object_and_attribute_name(obj,attribute)+")"
      end


      code << " ]} in true /\\ sum(t0 in 1.." + objects.size.to_s + ")(array" +index.to_s + "[t0])"
    end

    def translate_expression_default(expression, problem)
      code = ''
      code << resolve_expression(expression.left, problem) + SPACE
      code << expression.operator.to_s
      code << SPACE + resolve_expression(expression.right, problem)
    end

    def resolve_expression(expression, problem)
      if expression.is_a? Yarpler::Models::Field
        resolve_variable_from_field(expression)
      elsif expression.is_a? Yarpler::Models::Expression
        MinizincExpressionTranslator.new.translate(expression, problem)
      end
    end

    def resolve_variable_from_field(field)
      field.variable + '_' + field.attribute
    end

    def resolve_variable_from_object_and_attribute_name(obj, attribute)
      obj.get_instance_name + '_' + attribute
    end
  end
end