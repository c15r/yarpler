module Yarpler
  module Translators
    class MinizincTranslator < Translator

      T_HEADER = "%% File generated by YARPLER"
      T_INCLUDES = "include \"globals.mzn\";"
      T_FOOTER = "solve satisfy;" # @TODO: Wird momentan als Hack missbraucht um den kompletten Durchstich zu ermÃ¶glichen ;)

      SPACE = ' '
      NEWLINE = "\n"
      DOUBLE_NEWLINE = NEWLINE * 2
      TAB = "\t"

      def translate(problem)
        # Setup HEADER and INCLUDES
        code = T_HEADER + DOUBLE_NEWLINE
        code << T_INCLUDES + DOUBLE_NEWLINE

        # Generate variables
        attribute_translator = MinizincAttributeTranslator.new
        code << attribute_translator.translate(problem.objects) + DOUBLE_NEWLINE

        # Generate constraints
        constraint_translator = MinizincConstraintTranslator.new
        code << constraint_translator.translate(problem.constraints) + DOUBLE_NEWLINE

        # Output
        code << 'output [ "" ' + attribute_translator.attribute_output + '];' + DOUBLE_NEWLINE

        # Footer
        code << T_FOOTER
        @output = code
      end

      class MinizincAttributeTranslator

        T_CONSTANT = "%s: %s = %s;\n" # int: id_dienst_frei = 0;
        T_OUTPUT = ", \"%s=\" , show(%s) , \" \"   "
        T_SET = "set of int: %s = {%s};\n"
        T_VARIABLE = "var %s: %s;\n" # var 0..2: m0t0;

        FIXNUM_MAX = (2**(0.size * 8 -2) -1)
        FIXNUM_MIN = -(2**(0.size * 8 -2))

        attr_reader :attribute_output

        def initialize
          @attribute_output = ''
        end

        def translate(objects)
          result = ''
          objects.each do |key, var|
            var.get_list_of_attributes
            result << convert_attributes(key, var)
          end
          result
        end

        def convert_attributes(name, resource, reference = false)
          code = ''
          resource.get_list_of_attributes.each do |a|
            case resource.get_variabletype(a)
              when 'CONSTANT'
                if reference
                  next
                end
                code<< T_CONSTANT % [resource.get_datatype(a), name +'_' + a, resource.load(a)]
              when 'VARIABLE'
                # @TODO wieder einbauen?
                #if !reference && resource.is_referenced
                #  next
                #end
                code<< T_VARIABLE % [resource.load(a), name + "_" + a]
                @attribute_output << T_OUTPUT % [name + "_" + a,name + "_" + a]
              when 'REFERENCE'
                i = 0
                resource.get_value(a).each do |r|

                  if r.kind_of?(Array)
                    ## Set
                    if constant_range?(r)
                      code << T_VARIABLE % [array_to_constant_range(r), name.to_s+"_"+ a +"_"+i.to_s]
                    else
                      set_name = "SET_"+name.to_s+"_"+ a+"_"+i.to_s
                      code << T_SET % [set_name, array_to_set_range(r)]
                      code << T_VARIABLE % [set_name, name.to_s+"_"+ a +"_"+i.to_s]
                    end
                    @attribute_output << T_OUTPUT % [name.to_s+"_"+ a +"_"+i.to_s,name.to_s+"_"+ a +"_"+i.to_s]
                    i=i.next
                  else
                    ## Einzelner Eintrag
                    code << convert_attributes(name.to_s+"_"+r.get_instance_name.to_s, r, true )
                  end

                end
            end
          end
          code
        end

        ## Checks if the range is constant (0,1,2) or not (0,1,3)
        def constant_range?(array)
          values = Array.new
          answer = true
          array.each do |o|
            values.push(o.id)
          end
          values.sort

          last_value = nil
          values.each do |v|

            if last_value.nil?
              last_value=v
              next
            end

            if last_value+1==v
              last_value=v
            else
              answer=false
              break
            end
          end
          answer
        end

        def array_to_set_range(array)
          range = ""
          is_first = true
          array.each do |o|
            if not is_first
              range << ", "
            end
            range << o.id.to_s
            is_first = false
          end
          range
        end

        def array_to_constant_range(array)
          min = FIXNUM_MAX
          max = FIXNUM_MIN
          array.each do |o|
            if min > o.id
              min = o.id
            end

            if max < o.id
              max = o.id
            end
          end
          min.to_s + '..' + max.to_s
        end
      end

      class MinizincConstraintTranslator
        def initialize

        end

        def translate(constraints)
          code = ''
          constraints.each do |constraint|
            code = 'constraint' + NEWLINE
            constraint.expressions.each do |expression|
              code << translate_expression(expression) + NEWLINE
            end
            code << ';' + DOUBLE_NEWLINE
          end
          code
        end

        def translate_expression(expression)
          code = TAB
          code << resolve_expression(expression.left) + SPACE
          code << expression.operator.to_s
          code << SPACE + resolve_expression(expression.right)
        end

        def resolve_expression(expression)
          if expression.is_a? Yarpler::Models::Field
            resolve_variable_from_field(expression)
          elsif expression.is_a? Yarpler::Models::Expression
            translate_expression(expression)
          end
        end

        def resolve_variable_from_field(field)
          field.variable + '_' + field.attribute
        end

      end

    end
  end
end