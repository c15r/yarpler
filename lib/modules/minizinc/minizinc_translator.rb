require_relative 'minizinc_runner'
require_relative 'minizinc_helper'
require_relative 'minizinc_helper'
require_relative 'output_parser'

# Translator implementation to convert the solution to Minizinc
class MinizincTranslator < Yarpler::Extensions::Translator

  # Header output for YARPL file
  T_HEADER = '%% File generated by YARPLER'

  # Include Header
  T_INCLUDES = "include \"globals.mzn\";"

  # Footer for problem declaration in MiniZinc
  T_FOOTER = ''

  # Blueprint for Constant translation
  T_CONSTANT = "%s: %s = %s;\n" # int: id_dienst_frei = 0;

  # Blueprint for Output translation
  T_OUTPUT = ", \"%s=\" , show(%s) , \" \"   "

  # Blueprint for Set translation
  T_SET = "set of int: %s = {%s};\n"

  # Blueprint for Variable translation
  T_VARIABLE = "var %s: %s;\n" # var 0..2: m0t0;

  # Blueprint for Variable set translation
  T_VARIABLE_SET = "var set of {%s}: %s;\n"

  # Maximum integer
  FIXNUM_MAX = (2**(0.size * 8 - 2) - 1)

  # Minimum integer
  FIXNUM_MIN = -(2**(0.size * 8 - 2))

  # Space symbol
  SPACE = ' '

  # Newline symbol
  NEWLINE = "\n"

  # Curly brackets left symbol
  LCBRACKET = '{'

  # Curly brackets right symbol
  RCBRACKET = '}'

  # Double newline symbol
  DOUBLE_NEWLINE = NEWLINE * 2

  # Tab symbol
  TAB = "\t"

  # Return array index for MiniZinc problems
  #
  # @return [void]
  def array_index
    @array_index = @array_index.next
    @array_index
  end

  # Does nothing
  #
  # @param problem [Yarpler::Models::Problem] yarpler problem
  # @return [Yarpler::Models::Problem] processed problem
  def before_translate(problem)
    problem
  end

  # Runs MiniZinc solver and the output parser
  #
  # @param problem [Yarpler::Models::Problem] yarpler problem
  # @return [Yarpler::Models::Problem] processed problem
  def after_translate(problem)
    minizinc_runner = MinizincRunner.new
    minizinc_runner.run(@output)

    OutputParser.new(minizinc_runner.output, problem)
    problem
  end

  # Translates the problem object to MiniZinc code
  #
  # @param problem [Yarpler::Models::Problem] yarpler problem
  # @return [String] generated minizinc code
  def translate(problem)
    # Initialize
    @array_index = 0

    # Setup HEADER and INCLUDES
    code = T_HEADER + DOUBLE_NEWLINE
    code << T_INCLUDES + DOUBLE_NEWLINE

    # Generate variables
    code << translate_solution(problem)

    # Footer
    code << T_FOOTER
    @output = code
  end

  # Translates just the problem part
  #
  # @param problem [Yarpler::Models::Problem] yarpler problem
  # @return [String] generated minizinc code
  def translate_solution(problem)
    code = ''
    attribute_translator = MinizincAttributeTranslator.new
    code << attribute_translator.translate(problem.objects) + DOUBLE_NEWLINE

    # Generate constraints
    constraint_translator = MinizincConstraintTranslator.new
    code << constraint_translator.translate(problem) + DOUBLE_NEWLINE

    # Generate solve instructions
    solve_translator = MinizincSolveTranslator.new
    code << solve_translator.translate(problem) + DOUBLE_NEWLINE

    # Output
    code << 'output [ "" ' + attribute_translator.attribute_output + '];' + DOUBLE_NEWLINE
    code
  end

  # Translates attributes from the solution to Minizinc variables or constants
  #
  # @attr_reader attribute [String] attribute output
  class MinizincAttributeTranslator
    attr_reader :attribute_output

    # Initializes the attribute
    def initialize
      @attribute_output = ''
    end

    # Translates the attribute
    #
    # @param objects [Hash<String, Yarpler::Models::Resource] hash map of all objects
    # @return [String] generated minizinc code
    def translate(objects)
      result = ''
      objects.each do |key, var|
        var.list_of_attributes
        result << convert_attributes(key, var)
      end
      result
    end

    # Converts the list of attributes to a string list
    #
    # @param name [String] attribute name
    # @param resource [Yarpler::Models::Resource] yarpl object
    # @return [String] generated minizinc code
    def convert_attributes(name, resource)
      code = ''
      resource.list_of_attributes.each do |a|
        code << translate_attribute(a, name, resource)
      end
      code
    end

    # rubocop:disable Metrics/MethodLength, Metrics/CyclomaticComplexity
    # Translates an attribute depending on the type
    #
    # @param a [Yarpler::Models::Field] attribute
    # @param name [String] attribute name
    # @param resource [Yarpler::Models::Resource] yarpl object
    # @return [String] generated minizinc code
    def translate_attribute(a, name, resource)
      case resource.get_variabletype(a)
        when 'CONSTANT'
          translate_constant(a, name, resource)
        when 'VARIABLE'
          translate_variable(a, name, resource)
        when 'VARIABLE_HASONE'
          translate_variable_hasone(a, resource)
        when 'CONSTANT_HASONE'
          translate_constant_relation(a, resource)
        when 'VARIABLE_HASMANY'
          translate_variable_hasmany(a, resource)
        when 'CONSTANT_HASMANY'
          translate_constant_relation(a, resource)
      end
    end
    # rubocop:enable Metrics/MethodLength, Metrics/CyclomaticComplexity

    # Translates a variable hasmany relation
    #
    # @param a [Yarpler::Models::Field] attribute
    # @param resource [Yarpler::Models::Resource] yarpl object
    # @return [String] generated minizinc code
    def translate_variable_hasmany(a, resource)
      r = resource.get_value(a)
      relation = MinizincRelationTranslator.new
      code = relation.translate_var_set(r)
      @attribute_output << relation.output
      code
    end

    # Translates a constant relation
    #
    # @param a [Yarpler::Models::Field] attribute
    # @param resource [Yarpler::Models::Resource] yarpl object
    # @return [String] generated minizinc code
    def translate_constant_relation(a, resource)
      r = resource.get_value(a)
      relation = MinizincRelationTranslator.new
      relation.translate_const(r)
    end

    # Translates a variable hasone relation
    #
    # @param a [Yarpler::Models::Field] attribute
    # @param resource [Yarpler::Models::Resource] yarpl object
    # @return [String] generated minizinc code
    def translate_variable_hasone(a, resource)
      r = resource.get_value(a)
      relation = MinizincRelationTranslator.new
      code = relation.translate_var(r)
      @attribute_output << relation.output
      code
    end

    # Translates a single variable
    #
    # @param a [Yarpler::Models::Field] attribute
    # @param name [String] attribute name
    # @param resource [Yarpler::Models::Resource] yarpl object
    # @return [String] generated minizinc code
    def translate_variable(a, name, resource)
      code = format(T_VARIABLE, resource.load(a), name + '_' + a)
      @attribute_output << format(T_OUTPUT, name + '_' + a, name + '_' + a)
      code
    end

    # Translates a constant
    #
    # @param a [Yarpler::Models::Field] attribute
    # @param name [String] attribute name
    # @param resource [Yarpler::Models::Resource] yarpl object
    # @return [String] generated minizinc code
    def translate_constant(a, name, resource)
      value = resource.load(a)
      unless value.nil?
        dt = resource.get_datatype(a)
        dt = 'int' if 'DATE'.include? dt
        code = format(T_CONSTANT, dt , name + '_' + a, value)
      end
      code
    end
  end

  # Translates relations to Minizinc variables
  #
  # @attr_accessor output [String] generated minizinc code
  class MinizincRelationTranslator
    attr_accessor :output

    # Initializes a translation
    #
    # @return [void]
    def initialize
      @output = ''
    end

    # Translates a constant
    #
    # @param relation [Yarpler::Models::Relation] yarpl relation object
    # @return [String] generated minizinc code
    def translate_const(relation)
      # @TODO is this always correct?
      code = ''
      var_name = MinizincFieldTranslator.new.resolve_variable_from_field(relation.from)
      if relation.to.size > 1
        code << format(T_SET, var_name, array_to_set_range(relation.to))
      else
        code << format(T_CONSTANT, 'int', var_name, relation.to[0].id)
      end
      code
    end

    # Translates a variable set
    #
    # @param relation [Yarpler::Models::Relation] yarpl relation object
    # @return [String] generated minizinc code
    def translate_var_set(relation)
      code = ''
      var_name = MinizincFieldTranslator.new.resolve_variable_from_field(relation.from)
      code << format(T_VARIABLE_SET, array_to_set_range(relation.to), var_name)
      @output << format(T_OUTPUT, var_name, var_name)
      code
    end

    # Translates a variable
    #
    # @param relation [Yarpler::Models::Relation] yarpl relation object
    # @return [String] generated minizinc code
    def translate_var(relation)
      code = ''
      var_name = MinizincFieldTranslator.new.resolve_variable_from_field(relation.from)
      if constant_range?(relation.to)
        code << translate_constant_range(relation, var_name)
      else
        code << translate_set_range(relation, var_name)
      end

      @output << format(T_OUTPUT, var_name, var_name)

      code
    end

    # Translates a constant range
    #
    # @param relation [Yarpler::Models::Relation] yarpl relation object
    # @param var_name [String] variable name
    # @return [String] generated minizinc code
    def translate_constant_range(relation, var_name)
      format(T_VARIABLE, array_to_constant_range(relation.to), var_name)
    end

    # Translates a set range
    #
    # @param relation [Yarpler::Models::Relation] yarpl relation object
    # @param var_name [String] variable name
    # @return [String] generated minizinc code
    def translate_set_range(relation, var_name)
      set_name = 'SET_' + var_name
      code = format(T_SET, set_name, array_to_set_range(relation.to))
      code << format(T_VARIABLE, set_name, var_name)
    end

    private

    # Checks if the range is constant (0,1,2) or not (0,1,3)
    #
    # @param array [Array] array to check
    # @return [Boolean] true if the array contains a constant range, false otherwise
    def constant_range?(array)
      values = initialize_values(array)
      last_value = nil
      answer = check_range(last_value, values)
      answer
    end

    # rubocop:disable Metrics/MethodLength
    # Checks if the range is continuous
    #
    # @param last_value [Object] last value of the array
    # @param values [Array] array to check
    # @return [Boolean] true if the array continuous a constant range, false otherwise
    def check_range(last_value, values)
      answer = true
      values.each do |value|
        if last_value.nil?
          last_value = value
          next
        end
        if last_value + 1 == value
          last_value = value
        else
          answer = false
          break
        end
      end
      answer
    end
    # rubocop:enable Metrics/MethodLength

    # initializes the values of an array
    #
    # @param array [Array] array to initialize
    # @return [Array] initialized array
    def initialize_values(array)
      values = []
      array.each do |o|
        values.push(o.id)
      end
      values.sort
      values
    end

    # Converts an array to a set range
    #
    # @param array [Array] array to to set
    # @return [Array] processed array
    def array_to_set_range(array)
      range = ''
      is_first = true
      array.each do |o|
        range << ', ' unless is_first
        range << o.id.to_s
        is_first = false
      end
      range
    end

    # Converts an array to a constant range
    #
    # @param array [Array] array to to set
    # @return [String] constant range
    def array_to_constant_range(array)
      min = FIXNUM_MAX
      max = FIXNUM_MIN
      array.each do |o|
        min = o.id  if min > o.id
        max = o.id if max < o.id
      end
      min.to_s + '..' + max.to_s
    end
  end

  ##
  # Translates operators to the Minizinc equivalents
  class MinizincOperatorTranslator

    # Initializes the Translator
    #
    # @return [void]
    def initialize
    end

    # Translates the operators
    #
    # @param operator [String] operator to translate
    # @return [String] generated minizinc code
    def translate(operator)
      case operator
        when 'and'
          '/\\'
        when 'or'
          '\\/'
        else
          operator
      end
    end
  end

  ##
  # Translate the solve section to minizinc
  class MinizincSolveTranslator

    # Initializes the Translator
    #
    # @return [void]
    def initialize
    end

    # Translates the solve part of a problem
    #
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate(problem)
      code = 'solve '
      code << translate_solve_expression(problem)
      code << ';' + DOUBLE_NEWLINE
      code
    end

    # Translates the solve part inner
    #
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate_solve_expression(problem)
      case problem.solve.statement
        when 'SATISFY'
          code = 'satisfy' + NEWLINE
        when 'MINIMIZE'
          code = 'minimize ' + MinizincExpressionTranslator.new.translate(problem.solve.expression, problem) + NEWLINE
        when 'MAXIMIZE'
          code = 'maximize ' + MinizincExpressionTranslator.new.translate(problem.solve.expression, problem) + NEWLINE
      end
      code
    end
  end

  ##
  # Translates constraints to Minizinc Constraints
  class MinizincConstraintTranslator

    # Initializes a translator
    #
    # @return [void]
    def initialize
    end

    # Translates a constraint block
    #
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate(problem)
      code = ''
      problem.constraints.each do |constraint|
        expression = constraint.expression
        if expression.is_a? Yarpler::Models::Expression
          code <<  'constraint' + NEWLINE
          code << TAB + MinizincExpressionTranslator.new.translate(expression, problem) + NEWLINE + ';' + DOUBLE_NEWLINE
        else
          # @TODO exception!
        end
      end
      code
    end
  end

  ##
  # Translates expressions to Minizinc expressions
  class MinizincExpressionTranslator

    # Initializes a translator
    #
    # @return [void]
    def initialize
    end

    # Outer translate for a expression
    #
    # @param expression [Yarpler::Models::Expression] yarpl expression
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @param context [Object] current expression context
    # @return [String] generated minizinc code
    def translate(expression, problem, context=nil)
      translate_expression(expression, problem, context)
    end

    # Recursive expression translation
    #
    # @param expression [Yarpler::Models::Expression] yarpl expression
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @param context [Object] current expression context
    # @return [String] generated minizinc code
    def translate_expression(expression, problem, context)
      code = ''
      code << resolve_expression(expression.left, problem, context) + SPACE

      # no operator and right for literal expressions
      if expression.operator.to_s != 'LITERAL' && expression.operator.to_s != 'NOT'
        code << MinizincOperatorTranslator.new.translate(expression.operator.to_s)
        code << SPACE + resolve_expression(expression.right, problem, context)
      end
      code
    end

    # rubocop:disable Metrics/MethodLength, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity
    # Resolves a single expression
    #
    # @param expression [Yarpler::Models::Expression] yarpl expression
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @param context [Object] current expression context
    # @return [String] generated minizinc code
    def resolve_expression(expression, problem, context)
      if expression.is_a? Yarpler::Models::Field
        MinizincFieldTranslator.new.resolve_variable_from_field(expression, context)
      elsif expression.is_a? Yarpler::Models::Instance
        MinizincFieldTranslator.new.resolve_variable_from_instance(expression)
      elsif expression.is_a? Yarpler::Models::Absolute
        MinizincAbsoluteTranslator.new.translate(expression.expression, problem)
      elsif expression.is_a? Yarpler::Models::Not
        MinizincNotTranslator.new.translate(expression.expression, problem)
      elsif expression.is_a? Yarpler::Models::Function
        MinizincFunctionTranslator.new.translate(expression, problem)
      elsif expression.is_a? Yarpler::Models::Expression
        MinizincExpressionTranslator.new.translate(expression, problem)
      elsif expression.is_a? Yarpler::Models::Literal
        MinizincLiteralTranslator.new.translate(expression)
      end
    end
    # rubocop:enable Metrics/MethodLength, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity
  end

  ##
  # Translates an absolute expression to Minizinc
  class MinizincAbsoluteTranslator

    # Translates an absolute
    #
    # @param expression [Yarpler::Models::Expression] yarpl expression
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [void]
    def translate(expression, problem)
      code = 'abs('
      translate_expression(code, expression, problem)
      code << ')'
      code
    end

    # Translates an expression
    #
    # @param code [String] minizinc code
    # @param expression [Yarpler::Models::Expression] yarpl expression
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate_expression(code, expression, problem)
      if expression.is_a? Yarpler::Models::Field
        code << MinizincFieldTranslator.new.resolve_variable_from_field(expression)
      elsif expression.is_a? Yarpler::Models::Instance
        code << MinizincFieldTranslator.new.resolve_variable_from_instance(expression)
      elsif expression.is_a? Yarpler::Models::Expression
        code << MinizincExpressionTranslator.new.translate(expression, problem)
      elsif expression.is_a? Yarpler::Models::Literal
        code << MinizincLiteralTranslator.new.translate(expression)
      end
    end
  end

  ##
  # Translates a not expression to Minizinc
  class MinizincNotTranslator

    # Translates an inversion of an expression
    #
    # @param expression [Yarpler::Models::Expression] yarpl expression
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate(expression, problem)
      code = 'not('
      translate_expression(code, expression, problem)
      code << ')'
      code
    end

    # Translates a single not expression
    #
    # @param code [String] minizinc code
    # @param expression [Yarpler::Models::Expression] yarpl expression
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate_expression(code, expression, problem)
      if expression.is_a? Yarpler::Models::Field
        code << MinizincFieldTranslator.new.resolve_variable_from_field(expression)
      elsif expression.is_a? Yarpler::Models::Instance
        code << MinizincFieldTranslator.new.resolve_variable_from_instance(expression)
      elsif expression.is_a? Yarpler::Models::Expression
        code << MinizincExpressionTranslator.new.translate(expression, problem)
      elsif expression.is_a? Yarpler::Models::Literal
        code << MinizincLiteralTranslator.new.translate(expression)
      end
    end
  end

  ##
  # Translates a literal to a minizinc variable
  class MinizincLiteralTranslator

    # Translates a literal
    #
    # @param literal [Yarpler::Models::Literal] yarpl literal
    # @return [String] generated minizinc code
    def translate(literal)
      code = literal.value
      code
    end
  end

  ##
  # Translates a field or an instance to Minizinc
  class MinizincFieldTranslator

    # Resolves a variable to the id of the object
    #
    # @param field [Yarpler::Models::Field] yarpl field
    # @return [String] generated minizinc code
    def resolve_variable_from_instance(field)
      field.variable + '_id'
    end

    # Resolves a variable from a field
    #
    # @param field [Yarpler::Models::Field] yarpl field
    # @param context [Yarpler::Models::Context] current context
    # @return [String] generated minizinc code
    def resolve_variable_from_field(field, context=nil)
      if context
        context.get(field.variable.to_s) + '_' + field.attribute.to_s
      else
        field.variable.to_s + '_' + field.attribute.to_s
      end
    end
  end

  ##
  # Translates SUM or COUNT functions to Minizinc
  class MinizincFunctionTranslator

    # Initialize the translator
    #
    # @return [void]
    def initialize
    end

    # Translates the functions
    #
    # @param function [Yarpler::Models::Function] yarpl function
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate(function, problem)
      if function.is_a? Yarpler::Models::CountFunction
        translate_count_function(function, problem)
      elsif function.is_a? Yarpler::Models::SumValueFunction
        translate_sum_value_function(function, problem)
      elsif function.is_a? Yarpler::Models::Cardinality
        translate_cardinality(function)
      elsif function.is_a? Yarpler::Models::Countall
        translate_countall_function(function, problem)
      end
    end

    # Translates to a cardinality function
    #
    # @param function [Yarpler::Models::Function] yarpl function
    # @return [String] generated minizinc code
    def translate_cardinality(function)
      'card(' + MinizincFieldTranslator.new.resolve_variable_from_field(function.element) + ')'
    end

    # Translates to a sum value function
    #
    # @param function [Yarpler::Models::Function] yarpl function
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate_sum_value_function(function, problem)
      index = MinizincHelper.instance.array_id
      first = true
      objects = load_sum_objects(function, problem)

      code = 'let' + SPACE + LCBRACKET + 'array[1..' + objects.size.to_s + '] of var int: array' + index.to_s + ' = ['

      objects.each do |o|
        code << translate_sum_value_body(first, function, o, problem)
        first = false if first
      end

      code << ' ]} in sum(t0 in 1..' + objects.size.to_s + ')(array' + index.to_s + '[t0])'
    end

    # Loads the objects to sum up
    #
    # @param function [Yarpler::Models::Function] yarpl function
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [Array<Yarpler::Models::Resource>] function objects
    def load_sum_objects(function, problem)
      if function.elements.is_a?(Yarpler::Models::Relation)
        objects = function.elements.to
      elsif function.elements.is_a?(Yarpler::Models::Field)
        # @TODO Stimmt das immer?
        obj = problem.objects[function.elements.variable]
        objects = obj.get_value(function.elements.attribute).to
      else
        # @TODO : Mach Exception
      end
      objects
    end

    # Translates the body of a sum value function
    #
    # @param first [Boolean] first item
    # @param function [Yarpler::Models::Function] yarpl function
    # @param o [Yarpler::Models::Resource] yarpl object
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate_sum_value_body(first, function, o, problem)
      code = ''
      code << ',' unless first

      # operator in can be used for set of var
      operator = load_sum_operator(function, problem)
      code << resolve_variable_from_object_and_attribute_name(o, function.attribute)
      code << '*bool2int(' + o.id.to_s + ' ' + operator + ' '
      code << MinizincFieldTranslator.new.resolve_variable_from_field(function.set) + ')'
    end

    # Method to select the right operator for the sum
    #
    # @param function [Yarpler::Models::Function] yarpl function
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def load_sum_operator(function, problem)
      operator = 'in'
      case problem.objects[function.set.variable].get_variabletype(function.set.attribute)
        when 'VARIABLE_HASONE'
          operator = '=='
        when 'CONSTANT_HASONE'
          operator = '=='
      end
      operator
    end

    # Translates a count function
    #
    # @param function [Yarpler::Models::Function] yarpl function
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate_count_function(function, problem)
      index = MinizincHelper.instance.array_id
      first = true
      variable_to_check = function.element.variable + '_id'
      objects = problem.get_objects_of_class(function.range.variable)

      code = 'let' + SPACE + LCBRACKET + 'array[1..' + objects.size.to_s + '] of var int: array' + index.to_s + ' = ['
      objects.each do |obj|
        code << translate_count_body(function.range.attribute, first, obj, variable_to_check)
        first = false if first
      end

      code << ' ]} in sum(t0 in 1..' + objects.size.to_s + ')(array' + index.to_s + '[t0])'
    end

    # Translates the body of the cound function
    #
    # @param attribute [Yarpler::Models::Field] yarpl field
    # @param first [Boolean] first item
    # @param obj [Yarpler::Models::Resource] yarpl resource
    # @param variable_to_check [String] variable name to check
    # @return [String] generated minizinc code
    def translate_count_body(attribute, first, obj, variable_to_check)
      operator = '=='
      if obj.get_variabletype(attribute) == 'VARIABLE_HASMANY'
        operator = ' in '
      end
      code = ''
      code << ',' unless first
      code << 'bool2int('
      code << variable_to_check + operator + resolve_variable_from_object_and_attribute_name(obj, attribute)
      code << ')'
    end

    # Resolves the variable from an object and attribute name
    #
    # @param obj [Yarpler::Models::Resource] yarpl resource
    # @param attribute [String] attribute name of an object
    # @return [String] generated minizinc code
    def resolve_variable_from_object_and_attribute_name(obj, attribute)
      obj.instance_name + '_' + attribute
    end

    # Translates a countall function
    #
    # @param countall [Yarpler::Models::Countall] yarpl countall function
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate_countall_function(countall, problem)
      index = MinizincHelper.instance.array_id
      first = true
      objects = countall.expressions

      code = 'let' + SPACE + LCBRACKET + 'array[1..' + objects.size.to_s + '] of var int: array' + index.to_s + ' = ['

      objects.each do |item|
        code << translate_countall_body(first, countall, item, problem)
        first = false if first
      end

      code << ' ]} in sum(t0 in 1..' + objects.size.to_s + ')(array' + index.to_s + '[t0])'
    end

    # Translates the body of a countall
    #
    # @param first [Boolean] indicates if its the first item
    # @param countall [Yarpler::Models::Countall] yarpl countall function
    # @param item [Yarpler::Models::Expression] yarpl expression
    # @param problem [Yarpler::Models::Problem] yarpl problem
    # @return [String] generated minizinc code
    def translate_countall_body(first, countall, item, problem)
      code = ''
      code << ',' unless first

      code << 'bool2int('
      code << MinizincExpressionTranslator.new.translate(item, problem)
      code << ')'
    end
  end

  # Context of block structure for Minizinc
  #
  # @attr_accessor variable [Object]
  # @attr_accessor object [Object]
  # @attr_accessor variables [Hash<String, String>] has map of all variables in the context
  class MinizincContext
    attr_accessor :variable
    attr_accessor :object

    attr_accessor :variables

    # Initializes the context
    #
    # @return [void]
    def initialize()
      @variables = {}
    end

    # Adds a variable
    #
    # @param variable [String] variable name
    # @param replacement [String] value to replace the variable
    # @return [void]
    def add(variable, replacement)
      @variables[variable] = replacement
    end

    # Gets a variable
    #
    # @param variable [String] variable name to get
    # @return [String] variable value or name
    def get(variable)
      if @variables[variable]
        @variables[variable]
      else
        variable
      end
    end
  end
end
